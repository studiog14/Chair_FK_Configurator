<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>3D Chair Configurator</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      #loadingOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        font-size: 1.5em;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
      }
      .ui {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 20;
      }
      .ui button {
        margin-right: 10px;
        font-size: 1em;
        padding: 0.5em 1em;
      }
    </style>
  </head>

  <body>
    <div id="loadingOverlay">Loading 3D model...</div>
    <div class="ui">
      <button onclick="loadModel('models/Fargo.glb')">Fargo</button>
      <button onclick="loadModel('models/Marco.glb')">Marco</button>
    </div>

    <script type="module">
      import * as THREE from 'three';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 1, 5);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.set(1024, 1024);
      scene.add(directionalLight);

      const loader = new GLTFLoader();
      let currentModel;
      const loadingOverlay = document.getElementById('loadingOverlay');

      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();

      function startLoadingModel() {
        loadModel('models/Fargo.glb');
      }

      // Åadujemy HDR z obsÅ‚ugÄ… bÅ‚Ä™dÃ³w
      new RGBELoader()
        .setPath('hdr/')
        .load(
          'neon_photostudio_4k.hdr',
          (texture) => {
            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = envMap;
            scene.background = null; // lub: envMap dla tÅ‚a
            texture.dispose();
            pmremGenerator.dispose();
            console.log('âœ… HDR zaÅ‚adowany');
            startLoadingModel();
          },
          undefined,
          (error) => {
            console.error('âŒ BÅ‚Ä…d Å‚adowania HDR:', error);
            alert('Nie udaÅ‚o siÄ™ zaÅ‚adowaÄ‡ HDR, Å‚adujÄ™ model bez HDR');
            startLoadingModel();
          }
        );

      function loadModel(path) {
        console.log('ðŸ”„ Åadowanie modelu:', path);
        loadingOverlay.style.display = 'flex';

        if (currentModel) {
          scene.remove(currentModel);
          currentModel.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach((mat) => mat.dispose());
              } else {
                child.material.dispose();
              }
            }
          });
        }

        loader.load(
          path,
          (gltf) => {
            console.log('âœ… Model zaÅ‚adowany:', gltf);
            currentModel = gltf.scene;

            currentModel.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) child.material.needsUpdate = true;
              }
            });

            currentModel.position.set(0, 0, 0);
            currentModel.scale.set(1, 1, 1);
            scene.add(currentModel);

            const box = new THREE.Box3().setFromObject(currentModel);
            const size = box.getSize(new THREE.Vector3()).length();
            const center = box.getCenter(new THREE.Vector3());

            camera.position.set(center.x, center.y + size * 0.5, size * 1.5);
            camera.lookAt(center);

            loadingOverlay.style.display = 'none';
          },
          (xhr) => {
            if (xhr.lengthComputable) {
              const percent = ((xhr.loaded / xhr.total) * 100).toFixed(1);
              console.log(`ðŸ“¦ ZaÅ‚adowano: ${percent}%`);
            }
          },
          (error) => {
            console.error('âŒ BÅ‚Ä…d Å‚adowania modelu:', error);
            loadingOverlay.textContent = 'âŒ Error loading model :(';
          }
        );
      }

      function animate() {
        requestAnimationFrame(animate);
        if (currentModel) {
          currentModel.rotation.y += 0.001;
        }
        renderer.render(scene, camera);
      }
      animate();

      window.loadModel = loadModel;

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
